// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/basslove/daradara/internal/api/usecase/operator (interfaces: GetSightCategoriesInputPort,GetSightGenresInputPort,PostOperatorsInputPort,PostOperatorsSignInInputPort)

// Package usecase_operator is a generated GoMock package.
package usecase_operator

import (
	context "context"
	reflect "reflect"

	model "github.com/basslove/daradara/internal/api/domain/model"
	forms "github.com/basslove/daradara/internal/api/interface/presenter/forms"
	operator "github.com/basslove/daradara/internal/api/usecase/operator"
	gomock "github.com/golang/mock/gomock"
)

// MockGetSightCategoriesInputPort is a mock of GetSightCategoriesInputPort interface.
type MockGetSightCategoriesInputPort struct {
	ctrl     *gomock.Controller
	recorder *MockGetSightCategoriesInputPortMockRecorder
}

// MockGetSightCategoriesInputPortMockRecorder is the mock recorder for MockGetSightCategoriesInputPort.
type MockGetSightCategoriesInputPortMockRecorder struct {
	mock *MockGetSightCategoriesInputPort
}

// NewMockGetSightCategoriesInputPort creates a new mock instance.
func NewMockGetSightCategoriesInputPort(ctrl *gomock.Controller) *MockGetSightCategoriesInputPort {
	mock := &MockGetSightCategoriesInputPort{ctrl: ctrl}
	mock.recorder = &MockGetSightCategoriesInputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetSightCategoriesInputPort) EXPECT() *MockGetSightCategoriesInputPortMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockGetSightCategoriesInputPort) Execute(arg0 context.Context, arg1 *model.Operator, arg2 string, arg3, arg4 uint64) (*operator.GetSightCategoriesOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(*operator.GetSightCategoriesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockGetSightCategoriesInputPortMockRecorder) Execute(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetSightCategoriesInputPort)(nil).Execute), arg0, arg1, arg2, arg3, arg4)
}

// MockGetSightGenresInputPort is a mock of GetSightGenresInputPort interface.
type MockGetSightGenresInputPort struct {
	ctrl     *gomock.Controller
	recorder *MockGetSightGenresInputPortMockRecorder
}

// MockGetSightGenresInputPortMockRecorder is the mock recorder for MockGetSightGenresInputPort.
type MockGetSightGenresInputPortMockRecorder struct {
	mock *MockGetSightGenresInputPort
}

// NewMockGetSightGenresInputPort creates a new mock instance.
func NewMockGetSightGenresInputPort(ctrl *gomock.Controller) *MockGetSightGenresInputPort {
	mock := &MockGetSightGenresInputPort{ctrl: ctrl}
	mock.recorder = &MockGetSightGenresInputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetSightGenresInputPort) EXPECT() *MockGetSightGenresInputPortMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockGetSightGenresInputPort) Execute(arg0 context.Context, arg1 *model.Operator, arg2 string, arg3, arg4, arg5 uint64) (*operator.GetSightGenresOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(*operator.GetSightGenresOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockGetSightGenresInputPortMockRecorder) Execute(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetSightGenresInputPort)(nil).Execute), arg0, arg1, arg2, arg3, arg4, arg5)
}

// MockPostOperatorsInputPort is a mock of PostOperatorsInputPort interface.
type MockPostOperatorsInputPort struct {
	ctrl     *gomock.Controller
	recorder *MockPostOperatorsInputPortMockRecorder
}

// MockPostOperatorsInputPortMockRecorder is the mock recorder for MockPostOperatorsInputPort.
type MockPostOperatorsInputPortMockRecorder struct {
	mock *MockPostOperatorsInputPort
}

// NewMockPostOperatorsInputPort creates a new mock instance.
func NewMockPostOperatorsInputPort(ctrl *gomock.Controller) *MockPostOperatorsInputPort {
	mock := &MockPostOperatorsInputPort{ctrl: ctrl}
	mock.recorder = &MockPostOperatorsInputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostOperatorsInputPort) EXPECT() *MockPostOperatorsInputPortMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockPostOperatorsInputPort) Execute(arg0 context.Context, arg1 *forms.OperatorPostOperatorsForm) (*operator.PostOperatorsOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", arg0, arg1)
	ret0, _ := ret[0].(*operator.PostOperatorsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockPostOperatorsInputPortMockRecorder) Execute(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockPostOperatorsInputPort)(nil).Execute), arg0, arg1)
}

// MockPostOperatorsSignInInputPort is a mock of PostOperatorsSignInInputPort interface.
type MockPostOperatorsSignInInputPort struct {
	ctrl     *gomock.Controller
	recorder *MockPostOperatorsSignInInputPortMockRecorder
}

// MockPostOperatorsSignInInputPortMockRecorder is the mock recorder for MockPostOperatorsSignInInputPort.
type MockPostOperatorsSignInInputPortMockRecorder struct {
	mock *MockPostOperatorsSignInInputPort
}

// NewMockPostOperatorsSignInInputPort creates a new mock instance.
func NewMockPostOperatorsSignInInputPort(ctrl *gomock.Controller) *MockPostOperatorsSignInInputPort {
	mock := &MockPostOperatorsSignInInputPort{ctrl: ctrl}
	mock.recorder = &MockPostOperatorsSignInInputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostOperatorsSignInInputPort) EXPECT() *MockPostOperatorsSignInInputPortMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockPostOperatorsSignInInputPort) Execute(arg0 context.Context, arg1, arg2, arg3 string) (*operator.PostOperatorsSignInOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(*operator.PostOperatorsSignInOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockPostOperatorsSignInInputPortMockRecorder) Execute(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockPostOperatorsSignInInputPort)(nil).Execute), arg0, arg1, arg2, arg3)
}
