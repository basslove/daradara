// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/basslove/daradara/internal/api/usecase/customer (interfaces: PostCustomersInputPort,PostCustomersSignInInputPort,GetSightGenresInputPort)

// Package usecase_customer is a generated GoMock package.
package usecase_customer

import (
	context "context"
	reflect "reflect"

	model "github.com/basslove/daradara/internal/api/domain/model"
	forms "github.com/basslove/daradara/internal/api/interface/presenter/forms"
	customer "github.com/basslove/daradara/internal/api/usecase/customer"
	gomock "github.com/golang/mock/gomock"
)

// MockPostCustomersInputPort is a mock of PostCustomersInputPort interface.
type MockPostCustomersInputPort struct {
	ctrl     *gomock.Controller
	recorder *MockPostCustomersInputPortMockRecorder
}

// MockPostCustomersInputPortMockRecorder is the mock recorder for MockPostCustomersInputPort.
type MockPostCustomersInputPortMockRecorder struct {
	mock *MockPostCustomersInputPort
}

// NewMockPostCustomersInputPort creates a new mock instance.
func NewMockPostCustomersInputPort(ctrl *gomock.Controller) *MockPostCustomersInputPort {
	mock := &MockPostCustomersInputPort{ctrl: ctrl}
	mock.recorder = &MockPostCustomersInputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostCustomersInputPort) EXPECT() *MockPostCustomersInputPortMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockPostCustomersInputPort) Execute(arg0 context.Context, arg1 *forms.CustomerPostCustomersForm) (*customer.PostCustomersOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", arg0, arg1)
	ret0, _ := ret[0].(*customer.PostCustomersOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockPostCustomersInputPortMockRecorder) Execute(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockPostCustomersInputPort)(nil).Execute), arg0, arg1)
}

// MockPostCustomersSignInInputPort is a mock of PostCustomersSignInInputPort interface.
type MockPostCustomersSignInInputPort struct {
	ctrl     *gomock.Controller
	recorder *MockPostCustomersSignInInputPortMockRecorder
}

// MockPostCustomersSignInInputPortMockRecorder is the mock recorder for MockPostCustomersSignInInputPort.
type MockPostCustomersSignInInputPortMockRecorder struct {
	mock *MockPostCustomersSignInInputPort
}

// NewMockPostCustomersSignInInputPort creates a new mock instance.
func NewMockPostCustomersSignInInputPort(ctrl *gomock.Controller) *MockPostCustomersSignInInputPort {
	mock := &MockPostCustomersSignInInputPort{ctrl: ctrl}
	mock.recorder = &MockPostCustomersSignInInputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostCustomersSignInInputPort) EXPECT() *MockPostCustomersSignInInputPortMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockPostCustomersSignInInputPort) Execute(arg0 context.Context, arg1, arg2, arg3 string) (*customer.PostCustomersSignInOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(*customer.PostCustomersSignInOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockPostCustomersSignInInputPortMockRecorder) Execute(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockPostCustomersSignInInputPort)(nil).Execute), arg0, arg1, arg2, arg3)
}

// MockGetSightGenresInputPort is a mock of GetSightGenresInputPort interface.
type MockGetSightGenresInputPort struct {
	ctrl     *gomock.Controller
	recorder *MockGetSightGenresInputPortMockRecorder
}

// MockGetSightGenresInputPortMockRecorder is the mock recorder for MockGetSightGenresInputPort.
type MockGetSightGenresInputPortMockRecorder struct {
	mock *MockGetSightGenresInputPort
}

// NewMockGetSightGenresInputPort creates a new mock instance.
func NewMockGetSightGenresInputPort(ctrl *gomock.Controller) *MockGetSightGenresInputPort {
	mock := &MockGetSightGenresInputPort{ctrl: ctrl}
	mock.recorder = &MockGetSightGenresInputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetSightGenresInputPort) EXPECT() *MockGetSightGenresInputPortMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockGetSightGenresInputPort) Execute(arg0 context.Context, arg1 *model.Customer, arg2 string, arg3, arg4, arg5 uint64) (*customer.GetSightGenresOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(*customer.GetSightGenresOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockGetSightGenresInputPortMockRecorder) Execute(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetSightGenresInputPort)(nil).Execute), arg0, arg1, arg2, arg3, arg4, arg5)
}
